<HTML>
<HEAD>
<TITLE>class IAXEngine</TITLE>

<META NAME="Generator" CONTENT="KDOC ">
</HEAD>
<BODY bgcolor="#ffffff" text="#000000" link="#0000ff" vlink="#000099" alink= "#ffffff">
<TABLE WIDTH="100%" BORDER="0">
<TR>
<TD>
	<TABLE BORDER="0">
		<TR><TD valign="top" align="left" cellspacing="10">
		<h1>class IAXEngine</h1>
		</TD>
		<TD valign="top" align="right" colspan="1">IAX engine class. <small><A HREF="#longdesc">More...</A></small></TD></TR>
	</TABLE>
	<HR>
	<TABLE BORDER="0">
		<TR><TH>Full name</TH><TD><code><A HREF="TelEngine.html">TelEngine</A>::IAXEngine</code></TD></TR>
<TR><TH>Definition</TH><TD><code>#include &lt;<A HREF="libs___yiax___yateiax_h.html">libs/yiax/yateiax.h</A>&gt;</code></TD></TR>
<TR><TH>Inherits</TH><TD><A HREF="TelEngine__DebugEnabler.html">TelEngine::DebugEnabler</A> <small>[public ]</small>, <A HREF="TelEngine__Mutex.html">TelEngine::Mutex</A> <small>[public ]</small></TD></TR>
<TR><TH><A HREF="full-list-TelEngine__IAXEngine.html">List of all Methods</A></TH></TR>
	</TABLE>
	</TD>
<TD align="right"><TABLE BORDER="0"><TR><TD><small><A HREF="index-long.html">Annotated List</A></small></TD></TR>
<TR><TD><small><A HREF="header-list.html">Files</A></small></TD></TR>
<TR><TD><small><A HREF="all-globals.html">Globals</A></small></TD></TR>
<TR><TD><small><A HREF="hier.html">Hierarchy</A></small></TD></TR>
<TR><TD><small><A HREF="index.html">Index</A></small></TD></TR>
</TABLE></TD></TR></TABLE>
<h4>Public Methods</h4><ul><LI>&nbsp;<b><A HREF="#ref1">IAXEngine</A></b> (const char* iface, int port, <A HREF="#u_int32_t">u_int32_t</A> format, <A HREF="#u_int32_t">u_int32_t</A> capab,
	const NamedList* params = 0, const char* name = "iaxengine") 
</LI>
<LI>virtual  &nbsp;<b><A HREF="#ref2">~IAXEngine</A></b> () 
</LI>
<LI>inline const String& &nbsp;<b><A HREF="#ref3">name</A></b> ()  const
</LI>
<LI>inline <A HREF="#u_int8_t">u_int8_t</A> &nbsp;<b><A HREF="#ref4">callerNumType</A></b> ()  const
</LI>
<LI>inline <A HREF="#u_int8_t">u_int8_t</A> &nbsp;<b><A HREF="#ref5">callingPres</A></b> ()  const
</LI>
<LI>IAXTransaction* &nbsp;<b><A HREF="#ref6">addFrame</A></b> (const SocketAddr& addr, IAXFrame* frame) 
</LI>
<LI>IAXTransaction* &nbsp;<b><A HREF="#ref7">addFrame</A></b> (const SocketAddr& addr, const unsigned char* buf, unsigned int len) 
</LI>
<LI>IAXTransaction* &nbsp;<b><A HREF="#ref8">findTransaction</A></b> (const SocketAddr& addr, <A HREF="#u_int16_t">u_int16_t</A> rCallNo) 
</LI>
<LI>virtual  void &nbsp;<b><A HREF="#ref9">processMedia</A></b> (IAXTransaction* transaction, DataBlock& data, <A HREF="#u_int32_t">u_int32_t</A> tStamp,
	int type, bool mark) 
</LI>
<LI>bool &nbsp;<b><A HREF="#ref10">process</A></b> () 
</LI>
<LI>inline unsigned int &nbsp;<b><A HREF="#ref11">challengeTout</A></b> ()  const
</LI>
<LI>inline <A HREF="#u_int16_t">u_int16_t</A> &nbsp;<b><A HREF="#ref12">maxFullFrameDataLen</A></b> ()  const
</LI>
<LI>inline <A HREF="#u_int32_t">u_int32_t</A> &nbsp;<b><A HREF="#ref13">format</A></b> (bool audio = true)  const
</LI>
<LI>inline <A HREF="#u_int32_t">u_int32_t</A> &nbsp;<b><A HREF="#ref14">capability</A></b> ()  const
</LI>
<LI>inline void &nbsp;<b><A HREF="#ref15">getOutDataAdjust</A></b> (unsigned int& thres, unsigned int& over,
	unsigned int& under)  const
</LI>
<LI>void &nbsp;<b><A HREF="#ref16">initOutDataAdjust</A></b> (const NamedList& params, IAXTransaction* tr = 0) 
</LI>
<LI>void &nbsp;<b><A HREF="#ref17">initialize</A></b> (const NamedList& params) 
</LI>
<LI>void &nbsp;<b><A HREF="#ref18">readSocket</A></b> (SocketAddr& addr) 
</LI>
<LI>bool &nbsp;<b><A HREF="#ref19">writeSocket</A></b> (const void* buf, int len, const SocketAddr& addr, IAXFullFrame* frame = 0,
	unsigned int* sent = 0) 
</LI>
<LI>inline bool &nbsp;<b><A HREF="#ref20">writeSocket</A></b> (const SocketAddr& addr, IAXFullFrame* frame) 
</LI>
<LI>void &nbsp;<b><A HREF="#ref21">runGetEvents</A></b> () 
</LI>
<LI>void &nbsp;<b><A HREF="#ref22">removeTransaction</A></b> (IAXTransaction* transaction) 
</LI>
<LI>bool &nbsp;<b><A HREF="#ref23">haveTransactions</A></b> () 
</LI>
<LI><A HREF="#u_int32_t">u_int32_t</A> &nbsp;<b><A HREF="#ref24">transactionCount</A></b> () 
</LI>
<LI>void &nbsp;<b><A HREF="#ref25">keepAlive</A></b> (const SocketAddr& addr) 
</LI>
<LI>virtual  bool &nbsp;<b><A HREF="#ref26">mediaFormatChanged</A></b> (IAXTransaction* trans, int type, <A HREF="#u_int32_t">u_int32_t</A> format) 
</LI>
<LI>virtual  bool &nbsp;<b><A HREF="#ref27">checkCallToken</A></b> (const SocketAddr& addr, IAXFullFrame& frame) 
</LI>
<LI>bool &nbsp;<b><A HREF="#ref28">acceptFormatAndCapability</A></b> (IAXTransaction* trans, unsigned int* caps = 0,
	int type = IAXFormat::Audio) 
</LI>
<LI>virtual  void &nbsp;<b><A HREF="#ref29">defaultEventHandler</A></b> (IAXEvent* event) 
</LI>
<LI>inline bool &nbsp;<b><A HREF="#ref30">exiting</A></b> ()  const
</LI>
<LI>virtual  void &nbsp;<b><A HREF="#ref31">setExiting</A></b> () 
</LI>
<LI>void &nbsp;<b><A HREF="#ref32">enableTrunking</A></b> (IAXTransaction* trans, const NamedList* params,
	const String& prefix = String::empty()) 
</LI>
<LI>void &nbsp;<b><A HREF="#ref33">enableTrunking</A></b> (IAXTransaction* trans, IAXTrunkInfo& data) 
</LI>
<LI>void &nbsp;<b><A HREF="#ref34">initTrunkIn</A></b> (IAXTransaction* trans, const NamedList* params,
	const String& prefix = String::empty()) 
</LI>
<LI>void &nbsp;<b><A HREF="#ref35">initTrunkIn</A></b> (IAXTransaction* trans, IAXTrunkInfo& data) 
</LI>
<LI>inline bool &nbsp;<b><A HREF="#ref36">trunkInfo</A></b> (RefPointer<IAXTrunkInfo>& info) 
</LI>
<LI>void &nbsp;<b><A HREF="#ref37">sendInval</A></b> (IAXFullFrame* frame, const SocketAddr& addr) 
</LI>
<LI>void &nbsp;<b><A HREF="#ref38">runProcessTrunkFrames</A></b> () 
</LI>
<LI>inline Socket& &nbsp;<b><A HREF="#ref39">socket</A></b> () 
</LI>
<LI>inline const SocketAddr& &nbsp;<b><A HREF="#ref40">addr</A></b> ()  const
</LI>
<LI>inline void &nbsp;<b><A HREF="#ref41">setFormats</A></b> (<A HREF="#u_int32_t">u_int32_t</A> caps, <A HREF="#u_int32_t">u_int32_t</A> fmtAudio, <A HREF="#u_int32_t">u_int32_t</A> fmtVideo) 
</LI>
</ul><h4>Public Static Methods</h4><ul><LI>static  inline int &nbsp;<b><A HREF="#ref42">getPort</A></b> (const NamedList& params, const String& param = "port") 
</LI>
<LI>static  void &nbsp;<b><A HREF="#ref43">getMD5FromChallenge</A></b> (String& md5data, const String& challenge, const String& password) 
</LI>
<LI>static  bool &nbsp;<b><A HREF="#ref44">isMD5ChallengeCorrect</A></b> (const String& md5data, const String& challenge, const String& password) 
</LI>
<LI>static  void &nbsp;<b><A HREF="#ref45">buildAddrSecret</A></b> (String& buf, const String& secret,
	const SocketAddr& addr) 
</LI>
<LI>static  int &nbsp;<b><A HREF="#ref46">addrSecretAge</A></b> (const String& buf, const String& secret,
	const SocketAddr& addr) 
</LI>
<LI>static  inline void &nbsp;<b><A HREF="#ref47">addKeyword</A></b> (NamedList& list, const char* param,
	const TokenDict* tokens, unsigned int val) 
</LI>
<LI>static  void &nbsp;<b><A HREF="#ref48">decodeDateTime</A></b> (<A HREF="#u_int32_t">u_int32_t</A> dt, unsigned int& year, unsigned int& month,
	unsigned int& day, unsigned int& hour, unsigned int& minute, unsigned int& sec) 
</LI>
<LI>static  unsigned int &nbsp;<b><A HREF="#ref49">overallTout</A></b> (unsigned int interval = IAX2_RETRANS_INTERVAL_DEF,
	unsigned int nRetrans = IAX2_RETRANS_COUNT_DEF) 
</LI>
</ul><h4>Protected Methods</h4><ul><LI>bool &nbsp;<b><A HREF="#ref50">processTrunkFrames</A></b> (const Time& time = Time()) 
</LI>
<LI>virtual  void &nbsp;<b><A HREF="#ref51">processEvent</A></b> (IAXEvent* event) 
</LI>
<LI>IAXEvent* &nbsp;<b><A HREF="#ref52">getEvent</A></b> (const Time& now = Time()) 
</LI>
<LI><A HREF="#u_int16_t">u_int16_t</A> &nbsp;<b><A HREF="#ref53">generateCallNo</A></b> () 
</LI>
<LI>void &nbsp;<b><A HREF="#ref54">releaseCallNo</A></b> (<A HREF="#u_int16_t">u_int16_t</A> lcallno) 
</LI>
<LI>IAXTransaction* &nbsp;<b><A HREF="#ref55">startLocalTransaction</A></b> (IAXTransaction::Type type,
	const SocketAddr& addr, IAXIEList& ieList,
	bool refTrans = false, bool startTrans = true) 
</LI>
<LI>bool &nbsp;<b><A HREF="#ref56">bind</A></b> (const char* iface, int port, bool force) 
</LI>
</ul><h4>Protected Members</h4><ul><LI>int <b><A HREF="#ref57">m_trunking</A></b></LI>
</ul><HR><H2><A NAME="longdesc">Detailed Description</A></H2><p>
 This class holds all information needded to manipulate all IAX transactions and events
</p>
<A NAME="IAXEngine"></A><A NAME="ref1"></A><table width="100%"><tr bgcolor="#eeeeee"><td>&nbsp;<strong>IAXEngine</strong> (const char* iface, int port, <A HREF="#u_int32_t">u_int32_t</A> format, <A HREF="#u_int32_t">u_int32_t</A> capab,
	const NamedList* params = 0, const char* name = "iaxengine")
<br></td><td align="right"><h3><strong>IAXEngine</strong></h3></td></tr></table><p></p><p>
 Constructor
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>iface</i></TD><TD align="left" valign="top">Address of the interface to use, default all (0.0.0.0)
</TD></TR>
<TR><TD align="left" valign="top"><i>port</i></TD><TD align="left" valign="top">UDP port to run the protocol on
</TD></TR>
<TR><TD align="left" valign="top"><i>format</i></TD><TD align="left" valign="top">Default media format
</TD></TR>
<TR><TD align="left" valign="top"><i>capab</i></TD><TD align="left" valign="top">Media capabilities of this engine
</TD></TR>
<TR><TD align="left" valign="top"><i>params</i></TD><TD align="left" valign="top">Optional extra parameter list
</TD></TR>
<TR><TD align="left" valign="top"><i>name</i></TD><TD align="left" valign="top">Engine name
     </TD></TR>
</TABLE></P>
<A NAME="~IAXEngine"></A><A NAME="ref2"></A><table width="100%"><tr bgcolor="#eeeeee"><td> &nbsp;<strong>~IAXEngine</strong> ()
<br></td><td align="right"><h3><strong>~IAXEngine</strong></h3></td></tr></table><p> <small>[virtual]</small></p><p>
 Destructor
 Closes all transactions belonging to this engine and flush all queues
     </p>
<A NAME="name"></A><A NAME="ref3"></A><table width="100%"><tr bgcolor="#eeeeee"><td>inline const String& &nbsp;<strong>name</strong> ()
<br></td><td align="right"><h3><strong>name</strong></h3></td></tr></table><p> <small>[const]</small></p><p>
 Retrieve the engine name
</p>
<p><b>Returns</b>: Engine name
     </p>
<A NAME="callerNumType"></A><A NAME="ref4"></A><table width="100%"><tr bgcolor="#eeeeee"><td>inline <A HREF="#u_int8_t">u_int8_t</A> &nbsp;<strong>callerNumType</strong> ()
<br></td><td align="right"><h3><strong>callerNumType</strong></h3></td></tr></table><p> <small>[const]</small></p><p>
 Retrieve the default caller number type
</p>
<p><b>Returns</b>: Default caller number type
     </p>
<A NAME="callingPres"></A><A NAME="ref5"></A><table width="100%"><tr bgcolor="#eeeeee"><td>inline <A HREF="#u_int8_t">u_int8_t</A> &nbsp;<strong>callingPres</strong> ()
<br></td><td align="right"><h3><strong>callingPres</strong></h3></td></tr></table><p> <small>[const]</small></p><p>
 Retrieve the default caller number presentation and screening concatenated value
</p>
<p><b>Returns</b>: Default caller number presentation and screening
     </p>
<A NAME="addFrame"></A><A NAME="ref6"></A><table width="100%"><tr bgcolor="#eeeeee"><td>IAXTransaction* &nbsp;<strong>addFrame</strong> (const SocketAddr& addr, IAXFrame* frame)
<br></td><td align="right"><h3><strong>addFrame</strong></h3></td></tr></table><p></p><p>
 Add a parsed frame to the transaction list
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>addr</i></TD><TD align="left" valign="top">Address from which the frame was received
</TD></TR>
<TR><TD align="left" valign="top"><i>frame</i></TD><TD align="left" valign="top">A parsed IAX frame
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: Pointer to the transaction or 0 to deref the frame
     </p>
<A NAME="addFrame"></A><A NAME="ref7"></A><table width="100%"><tr bgcolor="#eeeeee"><td>IAXTransaction* &nbsp;<strong>addFrame</strong> (const SocketAddr& addr, const unsigned char* buf, unsigned int len)
<br></td><td align="right"><h3><strong>addFrame</strong></h3></td></tr></table><p></p><p>
 Add a raw frame to the transaction list
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>addr</i></TD><TD align="left" valign="top">Address from which the message was received
</TD></TR>
<TR><TD align="left" valign="top"><i>buf</i></TD><TD align="left" valign="top">Pointer to the start of the buffer holding the IAX frame
</TD></TR>
<TR><TD align="left" valign="top"><i>len</i></TD><TD align="left" valign="top">Length of the message buffer
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: Pointer to the transaction or 0
     </p>
<A NAME="findTransaction"></A><A NAME="ref8"></A><table width="100%"><tr bgcolor="#eeeeee"><td>IAXTransaction* &nbsp;<strong>findTransaction</strong> (const SocketAddr& addr, <A HREF="#u_int16_t">u_int16_t</A> rCallNo)
<br></td><td align="right"><h3><strong>findTransaction</strong></h3></td></tr></table><p></p><p>
 Find a complete transaction.
 This method is thread safe
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>addr</i></TD><TD align="left" valign="top">Remote address
</TD></TR>
<TR><TD align="left" valign="top"><i>rCallNo</i></TD><TD align="left" valign="top">Remote transaction call number
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: Referrenced pointer to the transaction or 0
     </p>
<A NAME="processMedia"></A><A NAME="ref9"></A><table width="100%"><tr bgcolor="#eeeeee"><td> void &nbsp;<strong>processMedia</strong> (IAXTransaction* transaction, DataBlock& data, <A HREF="#u_int32_t">u_int32_t</A> tStamp,
	int type, bool mark)
<br></td><td align="right"><h3><strong>processMedia</strong></h3></td></tr></table><p> <small>[virtual]</small></p><p>
 Process media from remote peer. Descendents must override this method
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>transaction</i></TD><TD align="left" valign="top">IAXTransaction that owns the call leg
</TD></TR>
<TR><TD align="left" valign="top"><i>data</i></TD><TD align="left" valign="top">Media data
</TD></TR>
<TR><TD align="left" valign="top"><i>tStamp</i></TD><TD align="left" valign="top">Media timestamp
</TD></TR>
<TR><TD align="left" valign="top"><i>type</i></TD><TD align="left" valign="top">Media type
</TD></TR>
<TR><TD align="left" valign="top"><i>mark</i></TD><TD align="left" valign="top">Mark flag
     </TD></TR>
</TABLE></P>
<A NAME="process"></A><A NAME="ref10"></A><table width="100%"><tr bgcolor="#eeeeee"><td>bool &nbsp;<strong>process</strong> ()
<br></td><td align="right"><h3><strong>process</strong></h3></td></tr></table><p></p><p>
 Event processor method. Keeps calling getEvent() and passing
  any events to processEvent() until there are no more events
</p>
<p><b>Returns</b>: True if at least one event was processed
     </p>
<A NAME="challengeTout"></A><A NAME="ref11"></A><table width="100%"><tr bgcolor="#eeeeee"><td>inline unsigned int &nbsp;<strong>challengeTout</strong> ()
<br></td><td align="right"><h3><strong>challengeTout</strong></h3></td></tr></table><p> <small>[const]</small></p><p>
 Get the timeout interval sent challenge
</p>
<p><b>Returns</b>: Sent challenge timeout interval
     </p>
<A NAME="maxFullFrameDataLen"></A><A NAME="ref12"></A><table width="100%"><tr bgcolor="#eeeeee"><td>inline <A HREF="#u_int16_t">u_int16_t</A> &nbsp;<strong>maxFullFrameDataLen</strong> ()
<br></td><td align="right"><h3><strong>maxFullFrameDataLen</strong></h3></td></tr></table><p> <small>[const]</small></p><p>
 Get the maximum allowed frame length
</p>
<p><b>Returns</b>: The maximum allowed frame length
     </p>
<A NAME="format"></A><A NAME="ref13"></A><table width="100%"><tr bgcolor="#eeeeee"><td>inline <A HREF="#u_int32_t">u_int32_t</A> &nbsp;<strong>format</strong> (bool audio = true)
<br></td><td align="right"><h3><strong>format</strong></h3></td></tr></table><p> <small>[const]</small></p><p>
 Get the default media format
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>audio</i></TD><TD align="left" valign="top">True to retrieve default audio format, false for video format
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: The default media format
     </p>
<A NAME="capability"></A><A NAME="ref14"></A><table width="100%"><tr bgcolor="#eeeeee"><td>inline <A HREF="#u_int32_t">u_int32_t</A> &nbsp;<strong>capability</strong> ()
<br></td><td align="right"><h3><strong>capability</strong></h3></td></tr></table><p> <small>[const]</small></p><p>
 Get the media capability of this engine
</p>
<p><b>Returns</b>: The media capability of this engine
     </p>
<A NAME="getOutDataAdjust"></A><A NAME="ref15"></A><table width="100%"><tr bgcolor="#eeeeee"><td>inline void &nbsp;<strong>getOutDataAdjust</strong> (unsigned int& thres, unsigned int& over,
	unsigned int& under)
<br></td><td align="right"><h3><strong>getOutDataAdjust</strong></h3></td></tr></table><p> <small>[const]</small></p><p>
 Retrieve outgoing data timestamp adjust values
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>thres</i></TD><TD align="left" valign="top">Adjust outgoing data timestamp threshold
</TD></TR>
<TR><TD align="left" valign="top"><i>over</i></TD><TD align="left" valign="top">Value used to adjust outgoing data timestamp on data overrun
</TD></TR>
<TR><TD align="left" valign="top"><i>under</i></TD><TD align="left" valign="top">Value used to adjust outgoing data timestamp on data underrun
     </TD></TR>
</TABLE></P>
<A NAME="initOutDataAdjust"></A><A NAME="ref16"></A><table width="100%"><tr bgcolor="#eeeeee"><td>void &nbsp;<strong>initOutDataAdjust</strong> (const NamedList& params, IAXTransaction* tr = 0)
<br></td><td align="right"><h3><strong>initOutDataAdjust</strong></h3></td></tr></table><p></p><p>
 Initialize outgoing data timestamp adjust values.
 This method is thread safe
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>params</i></TD><TD align="left" valign="top">Parameters list
</TD></TR>
<TR><TD align="left" valign="top"><i>tr</i></TD><TD align="left" valign="top">Optional transaction to init, initialize the engine's data if 0
     </TD></TR>
</TABLE></P>
<A NAME="initialize"></A><A NAME="ref17"></A><table width="100%"><tr bgcolor="#eeeeee"><td>void &nbsp;<strong>initialize</strong> (const NamedList& params)
<br></td><td align="right"><h3><strong>initialize</strong></h3></td></tr></table><p></p><p>
 (Re)Initialize the engine
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>params</i></TD><TD align="left" valign="top">Parameter list
     </TD></TR>
</TABLE></P>
<A NAME="readSocket"></A><A NAME="ref18"></A><table width="100%"><tr bgcolor="#eeeeee"><td>void &nbsp;<strong>readSocket</strong> (SocketAddr& addr)
<br></td><td align="right"><h3><strong>readSocket</strong></h3></td></tr></table><p></p><p>
 Read data from socket
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>addr</i></TD><TD align="left" valign="top">Socket to read from
     </TD></TR>
</TABLE></P>
<A NAME="writeSocket"></A><A NAME="ref19"></A><table width="100%"><tr bgcolor="#eeeeee"><td>bool &nbsp;<strong>writeSocket</strong> (const void* buf, int len, const SocketAddr& addr, IAXFullFrame* frame = 0,
	unsigned int* sent = 0)
<br></td><td align="right"><h3><strong>writeSocket</strong></h3></td></tr></table><p></p><p>
 Write data to socket.
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>buf</i></TD><TD align="left" valign="top">Data to write
</TD></TR>
<TR><TD align="left" valign="top"><i>len</i></TD><TD align="left" valign="top">Data length
</TD></TR>
<TR><TD align="left" valign="top"><i>addr</i></TD><TD align="left" valign="top">Socket to write to
</TD></TR>
<TR><TD align="left" valign="top"><i>frame</i></TD><TD align="left" valign="top">Optional frame to be printed
</TD></TR>
<TR><TD align="left" valign="top"><i>sent</i></TD><TD align="left" valign="top">Pointer to variable to be filled with the number of bytes sent
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: True on success
     </p>
<A NAME="writeSocket"></A><A NAME="ref20"></A><table width="100%"><tr bgcolor="#eeeeee"><td>inline bool &nbsp;<strong>writeSocket</strong> (const SocketAddr& addr, IAXFullFrame* frame)
<br></td><td align="right"><h3><strong>writeSocket</strong></h3></td></tr></table><p></p><p>
 Write a full frame to socket
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>addr</i></TD><TD align="left" valign="top">Socket to write to
</TD></TR>
<TR><TD align="left" valign="top"><i>frame</i></TD><TD align="left" valign="top">Frame to write
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: True on success
     </p>
<A NAME="runGetEvents"></A><A NAME="ref21"></A><table width="100%"><tr bgcolor="#eeeeee"><td>void &nbsp;<strong>runGetEvents</strong> ()
<br></td><td align="right"><h3><strong>runGetEvents</strong></h3></td></tr></table><p></p><p>
 Read events
     </p>
<A NAME="removeTransaction"></A><A NAME="ref22"></A><table width="100%"><tr bgcolor="#eeeeee"><td>void &nbsp;<strong>removeTransaction</strong> (IAXTransaction* transaction)
<br></td><td align="right"><h3><strong>removeTransaction</strong></h3></td></tr></table><p></p><p>
 Removes a transaction from queue. Free the allocated local call number
  Does not delete it
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>transaction</i></TD><TD align="left" valign="top">Transaction to remove
     </TD></TR>
</TABLE></P>
<A NAME="haveTransactions"></A><A NAME="ref23"></A><table width="100%"><tr bgcolor="#eeeeee"><td>bool &nbsp;<strong>haveTransactions</strong> ()
<br></td><td align="right"><h3><strong>haveTransactions</strong></h3></td></tr></table><p></p><p>
 Check if there are any transactions in the engine
 This method is thread safe
</p>
<p><b>Returns</b>: True if the engine holds at least 1 transaction
     </p>
<A NAME="transactionCount"></A><A NAME="ref24"></A><table width="100%"><tr bgcolor="#eeeeee"><td><A HREF="#u_int32_t">u_int32_t</A> &nbsp;<strong>transactionCount</strong> ()
<br></td><td align="right"><h3><strong>transactionCount</strong></h3></td></tr></table><p></p><p>
 Return the transactions count
 This method is thread safe
</p>
<p><b>Returns</b>: Transactions count
     </p>
<A NAME="keepAlive"></A><A NAME="ref25"></A><table width="100%"><tr bgcolor="#eeeeee"><td>void &nbsp;<strong>keepAlive</strong> (const SocketAddr& addr)
<br></td><td align="right"><h3><strong>keepAlive</strong></h3></td></tr></table><p></p><p>
 Send an INVAL with call numbers set to 0 to a remote peer to keep it alive
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>addr</i></TD><TD align="left" valign="top">Address to send to
     </TD></TR>
</TABLE></P>
<A NAME="mediaFormatChanged"></A><A NAME="ref26"></A><table width="100%"><tr bgcolor="#eeeeee"><td> bool &nbsp;<strong>mediaFormatChanged</strong> (IAXTransaction* trans, int type, <A HREF="#u_int32_t">u_int32_t</A> format)
<br></td><td align="right"><h3><strong>mediaFormatChanged</strong></h3></td></tr></table><p> <small>[virtual]</small></p><p>
 Process a new format received with a full frame
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>trans</i></TD><TD align="left" valign="top">Transaction that received the new format
</TD></TR>
<TR><TD align="left" valign="top"><i>type</i></TD><TD align="left" valign="top">Media type
</TD></TR>
<TR><TD align="left" valign="top"><i>format</i></TD><TD align="left" valign="top">The received format
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: True if accepted
     </p>
<A NAME="checkCallToken"></A><A NAME="ref27"></A><table width="100%"><tr bgcolor="#eeeeee"><td> bool &nbsp;<strong>checkCallToken</strong> (const SocketAddr& addr, IAXFullFrame& frame)
<br></td><td align="right"><h3><strong>checkCallToken</strong></h3></td></tr></table><p> <small>[virtual]</small></p><p>
 Check call token on incoming call requests.
 This method is called by the engine when processing an incoming call request
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>addr</i></TD><TD align="left" valign="top">The address from where the call request was received
</TD></TR>
<TR><TD align="left" valign="top"><i>frame</i></TD><TD align="left" valign="top">Received frame
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: True if accepted, false to ignore the call
     </p>
<A NAME="acceptFormatAndCapability"></A><A NAME="ref28"></A><table width="100%"><tr bgcolor="#eeeeee"><td>bool &nbsp;<strong>acceptFormatAndCapability</strong> (IAXTransaction* trans, unsigned int* caps = 0,
	int type = IAXFormat::Audio)
<br></td><td align="right"><h3><strong>acceptFormatAndCapability</strong></h3></td></tr></table><p></p><p>
 Process the initial received format and capability.
 If accepted on exit will set the transaction format and capability
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>trans</i></TD><TD align="left" valign="top">Transaction that received the new format
</TD></TR>
<TR><TD align="left" valign="top"><i>caps</i></TD><TD align="left" valign="top">Optional codecs to set in transaction before processing
</TD></TR>
<TR><TD align="left" valign="top"><i>type</i></TD><TD align="left" valign="top">Media type
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: True if accepted
     </p>
<A NAME="defaultEventHandler"></A><A NAME="ref29"></A><table width="100%"><tr bgcolor="#eeeeee"><td> void &nbsp;<strong>defaultEventHandler</strong> (IAXEvent* event)
<br></td><td align="right"><h3><strong>defaultEventHandler</strong></h3></td></tr></table><p> <small>[virtual]</small></p><p>
 Default event handler. event MUST NOT be deleted
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>event</i></TD><TD align="left" valign="top">The event to handle
     </TD></TR>
</TABLE></P>
<A NAME="exiting"></A><A NAME="ref30"></A><table width="100%"><tr bgcolor="#eeeeee"><td>inline bool &nbsp;<strong>exiting</strong> ()
<br></td><td align="right"><h3><strong>exiting</strong></h3></td></tr></table><p> <small>[const]</small></p><p>
 Check if the engine is exiting
</p>
<p><b>Returns</b>: True if the engine is exiting
     </p>
<A NAME="setExiting"></A><A NAME="ref31"></A><table width="100%"><tr bgcolor="#eeeeee"><td> void &nbsp;<strong>setExiting</strong> ()
<br></td><td align="right"><h3><strong>setExiting</strong></h3></td></tr></table><p> <small>[virtual]</small></p><p>
 Set the exiting flag
     </p>
<A NAME="enableTrunking"></A><A NAME="ref32"></A><table width="100%"><tr bgcolor="#eeeeee"><td>void &nbsp;<strong>enableTrunking</strong> (IAXTransaction* trans, const NamedList* params,
	const String& prefix = String::empty())
<br></td><td align="right"><h3><strong>enableTrunking</strong></h3></td></tr></table><p></p><p>
 Enable trunking for the given transaction. Allocate a trunk meta frame if needed.
 Trunk data is ignored if a trunk object for transaction remote address already exists
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>trans</i></TD><TD align="left" valign="top">Transaction to enable trunking for
</TD></TR>
<TR><TD align="left" valign="top"><i>params</i></TD><TD align="left" valign="top">Trunk parameters list, may be 0
</TD></TR>
<TR><TD align="left" valign="top"><i>prefix</i></TD><TD align="left" valign="top">Trunk parameters name prefix
     </TD></TR>
</TABLE></P>
<A NAME="enableTrunking"></A><A NAME="ref33"></A><table width="100%"><tr bgcolor="#eeeeee"><td>void &nbsp;<strong>enableTrunking</strong> (IAXTransaction* trans, IAXTrunkInfo& data)
<br></td><td align="right"><h3><strong>enableTrunking</strong></h3></td></tr></table><p></p><p>
 Enable trunking for the given transaction. Allocate a trunk meta frame if needed.
 Trunk data is ignored if a trunk object for transaction remote address already exists
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>trans</i></TD><TD align="left" valign="top">Transaction to enable trunking for
</TD></TR>
<TR><TD align="left" valign="top"><i>data</i></TD><TD align="left" valign="top">Trunk info to use
     </TD></TR>
</TABLE></P>
<A NAME="initTrunkIn"></A><A NAME="ref34"></A><table width="100%"><tr bgcolor="#eeeeee"><td>void &nbsp;<strong>initTrunkIn</strong> (IAXTransaction* trans, const NamedList* params,
	const String& prefix = String::empty())
<br></td><td align="right"><h3><strong>initTrunkIn</strong></h3></td></tr></table><p></p><p>
 Init incoming trunking data for a given transaction
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>trans</i></TD><TD align="left" valign="top">Transaction to init
</TD></TR>
<TR><TD align="left" valign="top"><i>params</i></TD><TD align="left" valign="top">Trunk parameters list, may be 0
</TD></TR>
<TR><TD align="left" valign="top"><i>prefix</i></TD><TD align="left" valign="top">Trunk parameters name prefix
     </TD></TR>
</TABLE></P>
<A NAME="initTrunkIn"></A><A NAME="ref35"></A><table width="100%"><tr bgcolor="#eeeeee"><td>void &nbsp;<strong>initTrunkIn</strong> (IAXTransaction* trans, IAXTrunkInfo& data)
<br></td><td align="right"><h3><strong>initTrunkIn</strong></h3></td></tr></table><p></p><p>
 Init incoming trunking data for a given transaction
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>trans</i></TD><TD align="left" valign="top">Transaction to init
</TD></TR>
<TR><TD align="left" valign="top"><i>data</i></TD><TD align="left" valign="top">Trunk info to use
     </TD></TR>
</TABLE></P>
<A NAME="trunkInfo"></A><A NAME="ref36"></A><table width="100%"><tr bgcolor="#eeeeee"><td>inline bool &nbsp;<strong>trunkInfo</strong> (RefPointer<IAXTrunkInfo>& info)
<br></td><td align="right"><h3><strong>trunkInfo</strong></h3></td></tr></table><p></p><p>
 Retrieve the default trunk info data
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>info</i></TD><TD align="left" valign="top">Destination to be set with trunk info pointer
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: True if destination pointr is valid
     </p>
<A NAME="sendInval"></A><A NAME="ref37"></A><table width="100%"><tr bgcolor="#eeeeee"><td>void &nbsp;<strong>sendInval</strong> (IAXFullFrame* frame, const SocketAddr& addr)
<br></td><td align="right"><h3><strong>sendInval</strong></h3></td></tr></table><p></p><p>
 Send an INVAL frame
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>frame</i></TD><TD align="left" valign="top">Frame for which to send an INVAL frame
</TD></TR>
<TR><TD align="left" valign="top"><i>addr</i></TD><TD align="left" valign="top">The address from where the call request was received
     </TD></TR>
</TABLE></P>
<A NAME="runProcessTrunkFrames"></A><A NAME="ref38"></A><table width="100%"><tr bgcolor="#eeeeee"><td>void &nbsp;<strong>runProcessTrunkFrames</strong> ()
<br></td><td align="right"><h3><strong>runProcessTrunkFrames</strong></h3></td></tr></table><p></p><p>
 Keep calling processTrunkFrames to send trunked media data
     </p>
<A NAME="socket"></A><A NAME="ref39"></A><table width="100%"><tr bgcolor="#eeeeee"><td>inline Socket& &nbsp;<strong>socket</strong> ()
<br></td><td align="right"><h3><strong>socket</strong></h3></td></tr></table><p></p><p>
 Get the socket used for engine operation
</p>
<p><b>Returns</b>: Reference to the UDP socket
     </p>
<A NAME="addr"></A><A NAME="ref40"></A><table width="100%"><tr bgcolor="#eeeeee"><td>inline const SocketAddr& &nbsp;<strong>addr</strong> ()
<br></td><td align="right"><h3><strong>addr</strong></h3></td></tr></table><p> <small>[const]</small></p><p>
 Retrieve the socket address on wgich we are bound
</p>
<p><b>Returns</b>: Local address we are bound on
     </p>
<A NAME="setFormats"></A><A NAME="ref41"></A><table width="100%"><tr bgcolor="#eeeeee"><td>inline void &nbsp;<strong>setFormats</strong> (<A HREF="#u_int32_t">u_int32_t</A> caps, <A HREF="#u_int32_t">u_int32_t</A> fmtAudio, <A HREF="#u_int32_t">u_int32_t</A> fmtVideo)
<br></td><td align="right"><h3><strong>setFormats</strong></h3></td></tr></table><p></p><p>
 Send engine formats
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>caps</i></TD><TD align="left" valign="top">Capabilities
</TD></TR>
<TR><TD align="left" valign="top"><i>fmtAudio</i></TD><TD align="left" valign="top">Default audio format
</TD></TR>
<TR><TD align="left" valign="top"><i>fmtVideo</i></TD><TD align="left" valign="top">Default video format
     </TD></TR>
</TABLE></P>
<A NAME="getPort"></A><A NAME="ref42"></A><table width="100%"><tr bgcolor="#eeeeee"><td> inline int &nbsp;<strong>getPort</strong> (const NamedList& params, const String& param = "port")
<br></td><td align="right"><h3><strong>getPort</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 Retrieve a port parameter
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>params</i></TD><TD align="left" valign="top">Parameters list
</TD></TR>
<TR><TD align="left" valign="top"><i>param</i></TD><TD align="left" valign="top">Parameter to retrieve
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: The port (default, 4569, if the parameter is missing or invalid)
     </p>
<A NAME="getMD5FromChallenge"></A><A NAME="ref43"></A><table width="100%"><tr bgcolor="#eeeeee"><td> void &nbsp;<strong>getMD5FromChallenge</strong> (String& md5data, const String& challenge, const String& password)
<br></td><td align="right"><h3><strong>getMD5FromChallenge</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 Get the MD5 data from a challenge and a password
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>md5data</i></TD><TD align="left" valign="top">Destination String
</TD></TR>
<TR><TD align="left" valign="top"><i>challenge</i></TD><TD align="left" valign="top">Challenge source
</TD></TR>
<TR><TD align="left" valign="top"><i>password</i></TD><TD align="left" valign="top">Password source
     </TD></TR>
</TABLE></P>
<A NAME="isMD5ChallengeCorrect"></A><A NAME="ref44"></A><table width="100%"><tr bgcolor="#eeeeee"><td> bool &nbsp;<strong>isMD5ChallengeCorrect</strong> (const String& md5data, const String& challenge, const String& password)
<br></td><td align="right"><h3><strong>isMD5ChallengeCorrect</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 Test if a received response to an authentication request is correct
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>md5data</i></TD><TD align="left" valign="top">Data to compare with
</TD></TR>
<TR><TD align="left" valign="top"><i>challenge</i></TD><TD align="left" valign="top">Received challenge
</TD></TR>
<TR><TD align="left" valign="top"><i>password</i></TD><TD align="left" valign="top">Password source
     </TD></TR>
</TABLE></P>
<A NAME="buildAddrSecret"></A><A NAME="ref45"></A><table width="100%"><tr bgcolor="#eeeeee"><td> void &nbsp;<strong>buildAddrSecret</strong> (String& buf, const String& secret,
	const SocketAddr& addr)
<br></td><td align="right"><h3><strong>buildAddrSecret</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 Build a time signed secret used to authenticate an IP address
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>buf</i></TD><TD align="left" valign="top">Destination buffer
</TD></TR>
<TR><TD align="left" valign="top"><i>secret</i></TD><TD align="left" valign="top">Extra secret to add to MD5 sum
</TD></TR>
<TR><TD align="left" valign="top"><i>addr</i></TD><TD align="left" valign="top">Socket address
     </TD></TR>
</TABLE></P>
<A NAME="addrSecretAge"></A><A NAME="ref46"></A><table width="100%"><tr bgcolor="#eeeeee"><td> int &nbsp;<strong>addrSecretAge</strong> (const String& buf, const String& secret,
	const SocketAddr& addr)
<br></td><td align="right"><h3><strong>addrSecretAge</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 Decode a secret built using buildAddrSecret()
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>buf</i></TD><TD align="left" valign="top">Input buffer
</TD></TR>
<TR><TD align="left" valign="top"><i>secret</i></TD><TD align="left" valign="top">Extra secret to check
</TD></TR>
<TR><TD align="left" valign="top"><i>addr</i></TD><TD align="left" valign="top">Socket address
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: Secret age, negative if invalid
     </p>
<A NAME="addKeyword"></A><A NAME="ref47"></A><table width="100%"><tr bgcolor="#eeeeee"><td> inline void &nbsp;<strong>addKeyword</strong> (NamedList& list, const char* param,
	const TokenDict* tokens, unsigned int val)
<br></td><td align="right"><h3><strong>addKeyword</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 Add string (keyword) if found in a dictionary or integer parameter to a named list
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>list</i></TD><TD align="left" valign="top">Destination list
</TD></TR>
<TR><TD align="left" valign="top"><i>param</i></TD><TD align="left" valign="top">Parameter to add to the list
</TD></TR>
<TR><TD align="left" valign="top"><i>tokens</i></TD><TD align="left" valign="top">The dictionary used to find the given value
</TD></TR>
<TR><TD align="left" valign="top"><i>val</i></TD><TD align="left" valign="top">The value to find/add to the list
     </TD></TR>
</TABLE></P>
<A NAME="decodeDateTime"></A><A NAME="ref48"></A><table width="100%"><tr bgcolor="#eeeeee"><td> void &nbsp;<strong>decodeDateTime</strong> (<A HREF="#u_int32_t">u_int32_t</A> dt, unsigned int& year, unsigned int& month,
	unsigned int& day, unsigned int& hour, unsigned int& minute, unsigned int& sec)
<br></td><td align="right"><h3><strong>decodeDateTime</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 Decode a DATETIME value
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>dt</i></TD><TD align="left" valign="top">Value to decode
</TD></TR>
<TR><TD align="left" valign="top"><i>year</i></TD><TD align="left" valign="top">The year component of the date
</TD></TR>
<TR><TD align="left" valign="top"><i>month</i></TD><TD align="left" valign="top">The month component of the date
</TD></TR>
<TR><TD align="left" valign="top"><i>day</i></TD><TD align="left" valign="top">The day component of the date
</TD></TR>
<TR><TD align="left" valign="top"><i>hour</i></TD><TD align="left" valign="top">The hour component of the time
</TD></TR>
<TR><TD align="left" valign="top"><i>minute</i></TD><TD align="left" valign="top">The minute component of the time
</TD></TR>
<TR><TD align="left" valign="top"><i>sec</i></TD><TD align="left" valign="top">The seconds component of the time
     </TD></TR>
</TABLE></P>
<A NAME="overallTout"></A><A NAME="ref49"></A><table width="100%"><tr bgcolor="#eeeeee"><td> unsigned int &nbsp;<strong>overallTout</strong> (unsigned int interval = IAX2_RETRANS_INTERVAL_DEF,
	unsigned int nRetrans = IAX2_RETRANS_COUNT_DEF)
<br></td><td align="right"><h3><strong>overallTout</strong></h3></td></tr></table><p> <small>[static]</small></p><p>
 Calculate overall timeout from interval and retransmission counter
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>interval</i></TD><TD align="left" valign="top">The first retransmisssion interval
</TD></TR>
<TR><TD align="left" valign="top"><i>nRetrans</i></TD><TD align="left" valign="top">The number of retransmissions
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: The overall timeout
     </p>
<A NAME="processTrunkFrames"></A><A NAME="ref50"></A><table width="100%"><tr bgcolor="#eeeeee"><td>bool &nbsp;<strong>processTrunkFrames</strong> (const Time& time = Time())
<br></td><td align="right"><h3><strong>processTrunkFrames</strong></h3></td></tr></table><p> <small>[protected]</small></p><p>
 Process all trunk meta frames in the queue
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>time</i></TD><TD align="left" valign="top">Time of the call
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: True if at least one frame was sent
     </p>
<A NAME="processEvent"></A><A NAME="ref51"></A><table width="100%"><tr bgcolor="#eeeeee"><td> void &nbsp;<strong>processEvent</strong> (IAXEvent* event)
<br></td><td align="right"><h3><strong>processEvent</strong></h3></td></tr></table><p> <small>[protected virtual]</small></p><p>
 Default event for connection transactions handler. This method may be overriden to perform custom
  processing
 This method is thread safe
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>event</i></TD><TD align="left" valign="top">Event to process
     </TD></TR>
</TABLE></P>
<A NAME="getEvent"></A><A NAME="ref52"></A><table width="100%"><tr bgcolor="#eeeeee"><td>IAXEvent* &nbsp;<strong>getEvent</strong> (const Time& now = Time())
<br></td><td align="right"><h3><strong>getEvent</strong></h3></td></tr></table><p> <small>[protected]</small></p><p>
 Get an IAX event from the queue.
 This method is thread safe.
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>now</i></TD><TD align="left" valign="top">Current time
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: Pointer to an IAXEvent or 0 if none is available
     </p>
<A NAME="generateCallNo"></A><A NAME="ref53"></A><table width="100%"><tr bgcolor="#eeeeee"><td><A HREF="#u_int16_t">u_int16_t</A> &nbsp;<strong>generateCallNo</strong> ()
<br></td><td align="right"><h3><strong>generateCallNo</strong></h3></td></tr></table><p> <small>[protected]</small></p><p>
 Generate call number. Update used call numbers list
</p>
<p><b>Returns</b>: Call number or 0 if none available
     </p>
<A NAME="releaseCallNo"></A><A NAME="ref54"></A><table width="100%"><tr bgcolor="#eeeeee"><td>void &nbsp;<strong>releaseCallNo</strong> (<A HREF="#u_int16_t">u_int16_t</A> lcallno)
<br></td><td align="right"><h3><strong>releaseCallNo</strong></h3></td></tr></table><p> <small>[protected]</small></p><p>
 Release a call number
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>lcallno</i></TD><TD align="left" valign="top">Call number to release
     </TD></TR>
</TABLE></P>
<A NAME="startLocalTransaction"></A><A NAME="ref55"></A><table width="100%"><tr bgcolor="#eeeeee"><td>IAXTransaction* &nbsp;<strong>startLocalTransaction</strong> (IAXTransaction::Type type,
	const SocketAddr& addr, IAXIEList& ieList,
	bool refTrans = false, bool startTrans = true)
<br></td><td align="right"><h3><strong>startLocalTransaction</strong></h3></td></tr></table><p> <small>[protected]</small></p><p>
 Start a transaction based on a local request
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>type</i></TD><TD align="left" valign="top">Transaction type
</TD></TR>
<TR><TD align="left" valign="top"><i>addr</i></TD><TD align="left" valign="top">Remote address to send the request
</TD></TR>
<TR><TD align="left" valign="top"><i>ieList</i></TD><TD align="left" valign="top">First frame IE list
</TD></TR>
<TR><TD align="left" valign="top"><i>refTrans</i></TD><TD align="left" valign="top">Return a refferenced transaction pointer
</TD></TR>
<TR><TD align="left" valign="top"><i>startTrans</i></TD><TD align="left" valign="top">Start transaction
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: IAXTransaction pointer on success
     </p>
<A NAME="bind"></A><A NAME="ref56"></A><table width="100%"><tr bgcolor="#eeeeee"><td>bool &nbsp;<strong>bind</strong> (const char* iface, int port, bool force)
<br></td><td align="right"><h3><strong>bind</strong></h3></td></tr></table><p> <small>[protected]</small></p><p>
 Bind the socket. Terminate it before trying
</p>
<p><b>Parameters</b>:<TABLE BORDER="0" CELLPADDING="5">
<TR><TD align="left" valign="top"><i>iface</i></TD><TD align="left" valign="top">Address of the interface to use, default all (0.0.0.0)
</TD></TR>
<TR><TD align="left" valign="top"><i>port</i></TD><TD align="left" valign="top">UDP port to run the protocol on
</TD></TR>
<TR><TD align="left" valign="top"><i>force</i></TD><TD align="left" valign="top">Force binding if failed on required port
</TD></TR>
</TABLE></P>
<p><b>Returns</b>: True on success
     </p>
<A NAME="m_trunking"></A><A NAME="ref57"></A><table width="100%"><tr bgcolor="#eeeeee"><td>int  <strong>m_trunking</strong>
</td><td align="right"><h3><strong>m_trunking</strong></h3></td></tr></table><p> <small>[protected]</small></p><HR>
	<table>
	<tr><td><small>Generated by: paulc on bussard on Thu Jul 24 18:41:02 2014, using kdoc 2.0a54.</small></td></tr>
	</table>
</BODY>
</HTML>
